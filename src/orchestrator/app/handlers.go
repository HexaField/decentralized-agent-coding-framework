package main

import (
    "fmt"
    "encoding/json"
    "errors"
    "io"
    "log"
    "net"
    "net/http"
    "net/http/httputil"
    "net/url"
    "os"
    "os/exec"
    "regexp"
    "strings"
    "sync"
    "time"
)

type Health struct {
    Status string `json:"status"`
    Host   string `json:"host"`
}

type Task struct {
    ID        string    `json:"id"`
    Org       string    `json:"org"`
    Text      string    `json:"text"`
    Status    string    `json:"status"`
    AgentHint string    `json:"agentHint,omitempty"`
    CreatedAt time.Time `json:"createdAt"`
    AgentID   string    `json:"agentId,omitempty"`
}

type Agent struct {
    Name   string            `json:"name"`
    Org    string            `json:"org"`
    Labels map[string]string `json:"labels,omitempty"`
    Status string            `json:"status"`
    LastSeen time.Time       `json:"lastSeen"`
    EditorPort int           `json:"editorPort,omitempty"`
    EditorVia  string        `json:"editorVia,omitempty"`
}

var (
    tasksMu sync.RWMutex
    tasks   = make(map[string]Task)

    agentsMu sync.RWMutex
    agents   = make(map[string]Agent)

    taskLogsMu sync.RWMutex
    taskLogs   = make(map[string][]string)

    agentLogsMu sync.RWMutex
    agentLogs   = make(map[string][]string)

    // SSE subscribers
    taskSubsMu sync.Mutex
    taskSubs   = make(map[string]map[chan string]struct{}) // id -> set of channels
    agentSubsMu sync.Mutex
    agentSubs   = make(map[string]map[chan string]struct{}) // name -> set of channels
    // editor port-forwards per agent
    editorMu sync.Mutex
    editorPF = make(map[string]*portFwd)
)

type portFwd struct {
    Port int
    Cmd  *exec.Cmd
}

// try to find a free port in a small range
func pickPort() int {
    // prefer 10080..10150 to avoid common local ports
    for p := 10080; p <= 10150; p++ {
        ln, err := net.Listen("tcp", ":"+itoa(p))
        if err == nil {
            ln.Close()
            return p
        }
    }
    // fallback: random by asking OS
    ln, err := net.Listen("tcp", ":0")
    if err != nil { return 0 }
    addr := ln.Addr().(*net.TCPAddr)
    port := addr.Port
    ln.Close()
    return port
}

// small helper for int->string
func itoa(i int) string { return fmt.Sprintf("%d", i) }

// ensureEditorForward starts (or returns) a kubectl port-forward to the agent's Service
func ensureEditorForward(name, org string) (int, error) {
    svcName := deriveServiceName(name)
    editorMu.Lock()
    if pf, ok := editorPF[name]; ok {
        port := pf.Port
        cmd := pf.Cmd
        editorMu.Unlock()
        // Validate the forward is still accepting connections; if not, restart it
        conn, err := net.DialTimeout("tcp", "127.0.0.1:"+itoa(port), 200*time.Millisecond)
        if err == nil {
            conn.Close()
            return port, nil
        }
        // kill stale forward and clear mapping
        if cmd != nil && cmd.Process != nil {
            _ = cmd.Process.Kill()
        }
        editorMu.Lock()
        delete(editorPF, name)
        if a, ok := agents[name]; ok {
            a.EditorPort = 0
            a.EditorVia = ""
            agents[name] = a
        }
        editorMu.Unlock()
    }
    editorMu.Unlock()

    // try a few ports until one binds and is ready
    for attempt := 0; attempt < 8; attempt++ {
        port := pickPort()
        if port == 0 { return 0, fmt.Errorf("no free port") }
        log.Printf("opening editor forward for %s via svc/%s on :%d", name, svcName, port)
        args := []string{"-n", "mvp-agents", "port-forward", "svc/"+svcName, itoa(port)+":8443", "--address=0.0.0.0"}
        cmd := exec.Command("kubectl", args...)
        // capture stderr for diagnostics
        stderr, _ := cmd.StderrPipe()
        // If org provided, prefer per-org kubeconfig generated by Talos bootstrap: ~/.kube/{org}.config
        if org != "" {
            home := os.Getenv("HOME"); if home == "" { home = "/root" }
            kube := home + "/.kube/" + org + ".config"
            if _, err := os.Stat(kube); err == nil {
                cmd.Env = append(os.Environ(), "KUBECONFIG="+kube)
            }
        }
        if err := cmd.Start(); err != nil {
            log.Printf("port-forward start error: %v", err)
            continue
        }
        go func() { io.Copy(os.Stdout, stderr) }()
        // wait up to ~3s for the local port to accept connects
        ready := false
        for i := 0; i < 30; i++ {
            conn, err := net.DialTimeout("tcp", "127.0.0.1:"+itoa(port), 100*time.Millisecond)
            if err == nil {
                conn.Close(); ready = true; break
            }
            time.Sleep(100 * time.Millisecond)
        }
        if !ready {
            _ = cmd.Process.Kill()
            log.Printf("port-forward not ready on :%d; retrying", port)
            continue
        }
        // success; record mapping
        editorMu.Lock()
        editorPF[name] = &portFwd{Port: port, Cmd: cmd}
        if a, ok := agents[name]; ok {
            a.EditorPort = port
            a.EditorVia = "orchestrator"
            agents[name] = a
        }
        editorMu.Unlock()
        go func(n string, c *exec.Cmd) {
            _ = c.Wait()
            editorMu.Lock()
            if pf, ok := editorPF[n]; ok && pf.Cmd == c {
                delete(editorPF, n)
                if a, ok := agents[n]; ok {
                    a.EditorPort = 0
                    a.EditorVia = ""
                    agents[n] = a
                }
            }
            editorMu.Unlock()
        }(name, cmd)
        return port, nil
    }
    return 0, fmt.Errorf("failed to establish port-forward for %s", name)
}

// deriveServiceName attempts to map a k8s pod name from a Deployment to the Service name created by deploy script.
// deploy script names Deployment and Service as agent-<timestamp> (e.g., agent-1690000000)
// Pod names look like agent-<timestamp>-<replicaset>-<podid> (e.g., agent-1690000000-68c7b795b9-6qtzm)
func deriveServiceName(podOrAgent string) string {
    // If it matches the pattern ending with -<rs>-<pod>, strip the last two segments
    re := regexp.MustCompile(`^(.*)-[a-z0-9]{9,10}-[a-z0-9]{5}$`)
    if m := re.FindStringSubmatch(podOrAgent); m != nil {
        return m[1]
    }
    // Otherwise, if it looks like agent-<timestamp>-something, take first two parts
    parts := strings.Split(podOrAgent, "-")
    if len(parts) >= 2 && strings.HasPrefix(podOrAgent, "agent-") {
        return parts[0] + "-" + parts[1]
    }
    // Fallback: return as-is
    return podOrAgent
}

func stopEditorForward(name string) bool {
    editorMu.Lock()
    pf, ok := editorPF[name]
    editorMu.Unlock()
    if !ok || pf.Cmd == nil { return false }
    // best-effort kill
    _ = pf.Cmd.Process.Kill()
    editorMu.Lock()
    delete(editorPF, name)
    if a, ok := agents[name]; ok {
        a.EditorPort = 0
        a.EditorVia = ""
        agents[name] = a
    }
    editorMu.Unlock()
    return true
}

func bearerOrHeaderToken(r *http.Request) string {
    // Prefer header X-Auth-Token, fallback to Authorization: Bearer <token>
    if t := r.Header.Get("X-Auth-Token"); t != "" { return t }
    if auth := r.Header.Get("Authorization"); auth != "" {
        const p = "Bearer "
        if len(auth) > len(p) && auth[:len(p)] == p { return auth[len(p):] }
    }
    return ""
}

func requireToken(next http.HandlerFunc, envVar string) http.HandlerFunc {
    required := os.Getenv(envVar)
    return func(w http.ResponseWriter, r *http.Request) {
        if required == "" { next(w, r); return }
        if token := bearerOrHeaderToken(r); token == required {
            next(w, r)
            return
        }
        http.Error(w, "unauthorized", http.StatusUnauthorized)
    }
}

func decodeJSON[T any](r *http.Request, v *T) error {
    b, err := io.ReadAll(r.Body)
    if err != nil { return err }
    if len(b) == 0 { return errors.New("empty body") }
    return json.Unmarshal(b, v)
}

func registerHandlers(mux *http.ServeMux) {
    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        h := Health{Status: "ok", Host: hostname()}
        writeJSON(w, h)
    })

    // Proxy endpoint to expose a local forwarded editor port over the orchestrator's HTTP port.
    // Usage: GET /editor/proxy/{port}/... -> http://127.0.0.1:{port}/...
    mux.HandleFunc("/editor/proxy/", func(w http.ResponseWriter, r *http.Request) {
        // path = /editor/proxy/{port}/rest...
        p := strings.TrimPrefix(r.URL.Path, "/editor/proxy/")
        if p == "" { http.Error(w, "missing port", 400); return }
        seg := strings.SplitN(p, "/", 2)
        portStr := seg[0]
        rest := "/"
        if len(seg) == 2 && seg[1] != "" { rest = "/" + seg[1] }
        // Validate port
        if _, err := fmt.Sscanf(portStr, "%d", new(int)); err != nil {
            http.Error(w, "bad port", 400); return
        }
        // Prepare reverse proxy to the locally-forwarded port
        target, _ := url.Parse("http://127.0.0.1:" + portStr)
        rp := httputil.NewSingleHostReverseProxy(target)
        // Relax frame headers and leave Location/Cookies as-is; dashboard will rewrite on its side
        rp.ModifyResponse = func(resp *http.Response) error {
            resp.Header.Del("X-Frame-Options")
            resp.Header.Del("Content-Security-Policy")
            return nil
        }
        orig := rp.Director
        // Optional auth header for fallback Python server
        csHeader := os.Getenv("CODE_SERVER_AUTH_HEADER"); if csHeader == "" { csHeader = "X-Agent-Auth" }
        csToken := os.Getenv("CODE_SERVER_TOKEN"); if csToken == "" { csToken = "password" }
        rp.Director = func(req *http.Request) {
            orig(req)
            req.URL.Scheme = "http"
            req.URL.Host = "127.0.0.1:" + portStr
            req.URL.Path = rest
            // Preserve query string
            req.Host = req.URL.Host
            req.Header.Set(csHeader, csToken)
        }
        rp.ErrorHandler = func(w http.ResponseWriter, req *http.Request, err error) {
            http.Error(w, "proxy error: "+err.Error(), 502)
        }
        rp.ServeHTTP(w, r)
    })

    mux.HandleFunc("/peers", func(w http.ResponseWriter, r *http.Request) {
        peers := []string{}
        writeJSON(w, map[string]any{"peers": peers})
    })

    mux.HandleFunc("/clusters", func(w http.ResponseWriter, r *http.Request) {
        clusters := []map[string]string{}
        writeJSON(w, map[string]any{"clusters": clusters})
    })

    mux.HandleFunc("/schedule", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct { Org string `json:"org"`; Task string `json:"task"`; AgentHint string `json:"agentHint,omitempty"` }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Org == "" || req.Task == "" { http.Error(w, "missing org/task", 400); return }
        id := time.Now().Format("20060102-150405.000")
        t := Task{ID: id, Org: req.Org, Text: req.Task, Status: "scheduled", AgentHint: req.AgentHint, CreatedAt: time.Now()}
        tasksMu.Lock(); tasks[id] = t; tasksMu.Unlock()
        log.Printf("scheduled task id=%s org=%s text=%q", id, req.Org, req.Task)
        writeJSON(w, t)
    }, "ORCHESTRATOR_TOKEN"))

    mux.HandleFunc("/tasks", func(w http.ResponseWriter, r *http.Request) {
        tasksMu.RLock(); defer tasksMu.RUnlock()
        out := make([]Task, 0, len(tasks))
        for _, t := range tasks { out = append(out, t) }
        writeJSON(w, out)
    })
    mux.HandleFunc("/tasks/claim", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Org, AgentID string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Org == "" || req.AgentID == "" { http.Error(w, "missing org/agentId", 400); return }
        // prefer tasks that hint this agent, otherwise first scheduled task for org
        tasksMu.Lock(); defer tasksMu.Unlock()
        // pass 1: agent-hinted
        for id, t := range tasks {
            if t.Org == req.Org && t.Status == "scheduled" && t.AgentHint == req.AgentID {
                t.Status = "running"; t.AgentID = req.AgentID; tasks[id] = t
                writeJSON(w, t); return
            }
        }
        // pass 2: any scheduled
        for id, t := range tasks {
            if t.Org == req.Org && t.Status == "scheduled" {
                t.Status = "running"; t.AgentID = req.AgentID; tasks[id] = t
                writeJSON(w, t); return
            }
        }
        writeJSON(w, map[string]any{"task": nil})
    })
    mux.HandleFunc("/tasks/update", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ ID, Status, Log string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.ID == "" || req.Status == "" { http.Error(w, "missing id/status", 400); return }
        tasksMu.Lock(); defer tasksMu.Unlock()
        t, ok := tasks[req.ID]; if !ok { http.Error(w, "not found", 404); return }
        t.Status = req.Status; tasks[req.ID] = t
        writeJSON(w, t)
    })
    mux.HandleFunc("/tasks/log", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ ID, Line string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.ID == "" { http.Error(w, "missing id", 400); return }
    if req.Line != "" { appendTaskLog(req.ID, req.Line); broadcastTask(req.ID, req.Line) }
        log.Printf("task[%s]: %s", req.ID, req.Line)
        w.WriteHeader(204)
    })
    mux.HandleFunc("/tasks/logs", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { http.Error(w, "method", 405); return }
        id := r.URL.Query().Get("id")
        if id == "" { http.Error(w, "missing id", 400); return }
        taskLogsMu.RLock(); lines := append([]string(nil), taskLogs[id]...); taskLogsMu.RUnlock()
        writeJSON(w, map[string]any{"id": id, "lines": lines})
    })
    // SSE: task logs
    mux.HandleFunc("/events/tasks", func(w http.ResponseWriter, r *http.Request) {
        id := r.URL.Query().Get("id")
        if id == "" { http.Error(w, "missing id", 400); return }
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        flusher, ok := w.(http.Flusher); if !ok { http.Error(w, "no flusher", 500); return }
        ch := make(chan string, 16)
        addTaskSub(id, ch); defer removeTaskSub(id, ch)
        // send backlog
        taskLogsMu.RLock(); for _, ln := range taskLogs[id] { io.WriteString(w, "data: "+ln+"\n\n") }; taskLogsMu.RUnlock(); flusher.Flush()
        notify := w.(http.CloseNotifier).CloseNotify()
        for {
            select {
            case ln := <-ch:
                io.WriteString(w, "data: "+ln+"\n\n"); flusher.Flush()
            case <-notify:
                return
            }
        }
    })
    mux.HandleFunc("/agents", func(w http.ResponseWriter, r *http.Request) {
        agentsMu.RLock(); defer agentsMu.RUnlock()
        out := make([]Agent, 0, len(agents))
        for _, a := range agents { out = append(out, a) }
        writeJSON(w, out)
    })
    mux.HandleFunc("/agents/register", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org string; Labels map[string]string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" || req.Org == "" { http.Error(w, "missing name/org", 400); return }
    a := Agent{Name: req.Name, Org: req.Org, Labels: req.Labels, Status: "idle", LastSeen: time.Now()}
        agentsMu.Lock(); agents[req.Name] = a; agentsMu.Unlock()
    // auto-open editor port-forward (best-effort)
    go func(name, org string) { _, _ = ensureEditorForward(name, org) }(req.Name, req.Org)
        writeJSON(w, a)
    })
    mux.HandleFunc("/agents/heartbeat", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org, Status string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        agentsMu.Lock(); a := agents[req.Name]; a.Name = req.Name; if req.Org != "" { a.Org = req.Org }; if req.Status != "" { a.Status = req.Status }; a.LastSeen = time.Now(); agents[req.Name] = a; agentsMu.Unlock()
        // best-effort ensure editor forward exists
        if a.EditorPort == 0 {
            go func(name, org string) { _, _ = ensureEditorForward(name, org) }(req.Name, req.Org)
        }
        writeJSON(w, map[string]string{"ok":"1"})
    })
    mux.HandleFunc("/agents/log", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Line string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
    if req.Line != "" { appendAgentLog(req.Name, req.Line); broadcastAgent(req.Name, req.Line) }
        log.Printf("agent[%s]: %s", req.Name, req.Line)
        w.WriteHeader(204)
    })
    mux.HandleFunc("/agents/logs", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { http.Error(w, "method", 405); return }
        name := r.URL.Query().Get("name")
        if name == "" { http.Error(w, "missing name", 400); return }
        agentLogsMu.RLock(); lines := append([]string(nil), agentLogs[name]...); agentLogsMu.RUnlock()
        writeJSON(w, map[string]any{"name": name, "lines": lines})
    })
    
    // SSE: agent logs
    mux.HandleFunc("/events/agents", func(w http.ResponseWriter, r *http.Request) {
        name := r.URL.Query().Get("name")
        if name == "" { http.Error(w, "missing name", 400); return }
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        flusher, ok := w.(http.Flusher); if !ok { http.Error(w, "no flusher", 500); return }
        ch := make(chan string, 16)
        addAgentSub(name, ch); defer removeAgentSub(name, ch)
        // send backlog
        agentLogsMu.RLock(); for _, ln := range agentLogs[name] { io.WriteString(w, "data: "+ln+"\n\n") }; agentLogsMu.RUnlock(); flusher.Flush()
        notify := w.(http.CloseNotifier).CloseNotify()
        for {
            select {
            case ln := <-ch:
                io.WriteString(w, "data: "+ln+"\n\n"); flusher.Flush()
            case <-notify:
                return
            }
        }
    })
    // Editor control endpoints (token-protected)
    mux.HandleFunc("/agents/editor/open", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        port, err := ensureEditorForward(req.Name, req.Org)
        if err != nil { http.Error(w, err.Error(), 500); return }
        writeJSON(w, map[string]any{"name": req.Name, "port": port})
    }, "ORCHESTRATOR_TOKEN"))
    mux.HandleFunc("/agents/editor/close", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        ok := stopEditorForward(req.Name)
        writeJSON(w, map[string]any{"name": req.Name, "stopped": ok})
    }, "ORCHESTRATOR_TOKEN"))
}

func writeJSON(w http.ResponseWriter, v any) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(v)
}

func hostname() string {
    h, _ := os.Hostname()
    return h
}

func appendTaskLog(id, line string) {
    taskLogsMu.Lock(); defer taskLogsMu.Unlock()
    b := append(taskLogs[id], time.Now().Format(time.RFC3339)+" "+line)
    if len(b) > 200 { b = b[len(b)-200:] }
    taskLogs[id] = b
}

func appendAgentLog(name, line string) {
    agentLogsMu.Lock(); defer agentLogsMu.Unlock()
    b := append(agentLogs[name], time.Now().Format(time.RFC3339)+" "+line)
    if len(b) > 200 { b = b[len(b)-200:] }
    agentLogs[name] = b
}

func addTaskSub(id string, ch chan string) {
    taskSubsMu.Lock(); defer taskSubsMu.Unlock()
    m := taskSubs[id]; if m == nil { m = make(map[chan string]struct{}); taskSubs[id] = m }
    m[ch] = struct{}{}
}
func removeTaskSub(id string, ch chan string) {
    taskSubsMu.Lock(); defer taskSubsMu.Unlock()
    if m := taskSubs[id]; m != nil { delete(m, ch) }
}
func broadcastTask(id, ln string) {
    taskSubsMu.Lock(); m := taskSubs[id]; taskSubsMu.Unlock()
    for ch := range m { select { case ch <- ln: default: } }
}

func addAgentSub(name string, ch chan string) {
    agentSubsMu.Lock(); defer agentSubsMu.Unlock()
    m := agentSubs[name]; if m == nil { m = make(map[chan string]struct{}); agentSubs[name] = m }
    m[ch] = struct{}{}
}
func removeAgentSub(name string, ch chan string) {
    agentSubsMu.Lock(); defer agentSubsMu.Unlock()
    if m := agentSubs[name]; m != nil { delete(m, ch) }
}
func broadcastAgent(name, ln string) {
    agentSubsMu.Lock(); m := agentSubs[name]; agentSubsMu.Unlock()
    for ch := range m { select { case ch <- ln: default: } }
}
