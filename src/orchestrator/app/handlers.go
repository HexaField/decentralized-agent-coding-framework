package main

import (
    "fmt"
    "encoding/json"
    "errors"
    "io"
    "log"
    "net"
    "net/http"
    "net/http/httputil"
    "net/url"
    "os"
    "os/exec"
    "regexp"
    "strings"
    "sync"
    "time"
)
import (
    cfg "orchestrator/config"
    k8sdep "orchestrator/k8s"
    k8sfactory "orchestrator/k8sclient"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    corev1 "k8s.io/api/core/v1"
)

type Health struct {
    Status string `json:"status"`
    Host   string `json:"host"`
}

type Task struct {
    ID        string    `json:"id"`
    Org       string    `json:"org"`
    Text      string    `json:"text"`
    Status    string    `json:"status"`
    AgentHint string    `json:"agentHint,omitempty"`
    CreatedAt time.Time `json:"createdAt"`
    AgentID   string    `json:"agentId,omitempty"`
}

type Agent struct {
    Name   string            `json:"name"`
    Org    string            `json:"org"`
    Labels map[string]string `json:"labels,omitempty"`
    Status string            `json:"status"`
    LastSeen time.Time       `json:"lastSeen"`
    EditorPort int           `json:"editorPort,omitempty"`
    EditorVia  string        `json:"editorVia,omitempty"`
}

var (
    tasksMu sync.RWMutex
    tasks   = make(map[string]Task)

    agentsMu sync.RWMutex
    agents   = make(map[string]Agent)

    taskLogsMu sync.RWMutex
    taskLogs   = make(map[string][]string)

    agentLogsMu sync.RWMutex
    agentLogs   = make(map[string][]string)

    // SSE subscribers
    taskSubsMu sync.Mutex
    taskSubs   = make(map[string]map[chan string]struct{}) // id -> set of channels
    agentSubsMu sync.Mutex
    agentSubs   = make(map[string]map[chan string]struct{}) // name -> set of channels
    // editor port-forwards per agent
    editorMu sync.Mutex
    editorPF = make(map[string]*portFwd)
)

type portFwd struct {
    Port int
    Cmd  *exec.Cmd
}

// try to find a free port in a small range
func pickPort() int {
    // prefer 10080..10150 to avoid common local ports
    for p := 10080; p <= 10150; p++ {
        ln, err := net.Listen("tcp", ":"+itoa(p))
        if err == nil {
            ln.Close()
            return p
        }
    }
    // fallback: random by asking OS
    ln, err := net.Listen("tcp", ":0")
    if err != nil { return 0 }
    addr := ln.Addr().(*net.TCPAddr)
    port := addr.Port
    ln.Close()
    return port
}

// small helper for int->string
func itoa(i int) string { return fmt.Sprintf("%d", i) }

func getenvDefault(k, def string) string {
    v := os.Getenv(k)
    if v == "" { return def }
    return v
}

// resolve a writable base directory for persistent state
// order: env HEXA_STATE_DIR or STATE_BASE_DIR -> /state -> ~/.hexa/state
func stateBaseDir() string {
    if v := os.Getenv("HEXA_STATE_DIR"); v != "" { _ = os.MkdirAll(v, 0o755); return v }
    if v := os.Getenv("STATE_BASE_DIR"); v != "" { _ = os.MkdirAll(v, 0o755); return v }
    if fi, err := os.Stat("/state"); err == nil && fi.IsDir() { _ = os.MkdirAll("/state", 0o755); return "/state" }
    home, _ := os.UserHomeDir()
    if home == "" { home = "." }
    base := home + "/.hexa/state"
    _ = os.MkdirAll(base, 0o755)
    return base
}

// ensureEditorForward starts (or returns) a kubectl port-forward to the agent's Service
func ensureEditorForward(name, org string) (int, error) {
    svcName := deriveServiceName(name)
    editorMu.Lock()
    if pf, ok := editorPF[name]; ok {
        port := pf.Port
        cmd := pf.Cmd
        editorMu.Unlock()
        // Validate the forward is still accepting connections; if not, restart it
        conn, err := net.DialTimeout("tcp", "127.0.0.1:"+itoa(port), 200*time.Millisecond)
        if err == nil {
            conn.Close()
            return port, nil
        }
        // kill stale forward and clear mapping
        if cmd != nil && cmd.Process != nil {
            _ = cmd.Process.Kill()
        }
        editorMu.Lock()
        delete(editorPF, name)
        if a, ok := agents[name]; ok {
            a.EditorPort = 0
            a.EditorVia = ""
            agents[name] = a
        }
        editorMu.Unlock()
    }
    editorMu.Unlock()

    // try a few ports until one binds and is ready
    for attempt := 0; attempt < 8; attempt++ {
        port := pickPort()
        if port == 0 { return 0, fmt.Errorf("no free port") }
        log.Printf("opening editor forward for %s via svc/%s on :%d", name, svcName, port)
        args := []string{"-n", "mvp-agents", "port-forward", "svc/"+svcName, itoa(port)+":8443", "--address=0.0.0.0"}
        cmd := exec.Command("kubectl", args...)
        // capture stderr for diagnostics
        stderr, _ := cmd.StderrPipe()
        // If org provided, prefer per-org kubeconfig generated by Talos bootstrap: ~/.kube/{org}.config
        if org != "" {
            home := os.Getenv("HOME"); if home == "" { home = "/root" }
            kube := home + "/.kube/" + org + ".config"
            if _, err := os.Stat(kube); err == nil {
                cmd.Env = append(os.Environ(), "KUBECONFIG="+kube)
            }
        }
        if err := cmd.Start(); err != nil {
            log.Printf("port-forward start error: %v", err)
            continue
        }
        go func() { io.Copy(os.Stdout, stderr) }()
        // wait up to ~3s for the local port to accept connects
        ready := false
        for i := 0; i < 30; i++ {
            conn, err := net.DialTimeout("tcp", "127.0.0.1:"+itoa(port), 100*time.Millisecond)
            if err == nil {
                conn.Close(); ready = true; break
            }
            time.Sleep(100 * time.Millisecond)
        }
        if !ready {
            _ = cmd.Process.Kill()
            log.Printf("port-forward not ready on :%d; retrying", port)
            continue
        }
        // success; record mapping
        editorMu.Lock()
        editorPF[name] = &portFwd{Port: port, Cmd: cmd}
        if a, ok := agents[name]; ok {
            a.EditorPort = port
            a.EditorVia = "orchestrator"
            agents[name] = a
        }
        editorMu.Unlock()
        go func(n string, c *exec.Cmd) {
            _ = c.Wait()
            editorMu.Lock()
            if pf, ok := editorPF[n]; ok && pf.Cmd == c {
                delete(editorPF, n)
                if a, ok := agents[n]; ok {
                    a.EditorPort = 0
                    a.EditorVia = ""
                    agents[n] = a
                }
            }
            editorMu.Unlock()
        }(name, cmd)
        return port, nil
    }
    return 0, fmt.Errorf("failed to establish port-forward for %s", name)
}

// deriveServiceName attempts to map a k8s pod name from a Deployment to the Service name created by deploy script.
// deploy script names Deployment and Service as agent-<timestamp> (e.g., agent-1690000000)
// Pod names look like agent-<timestamp>-<replicaset>-<podid> (e.g., agent-1690000000-68c7b795b9-6qtzm)
func deriveServiceName(podOrAgent string) string {
    // If it matches the pattern ending with -<rs>-<pod>, strip the last two segments
    re := regexp.MustCompile(`^(.*)-[a-z0-9]{9,10}-[a-z0-9]{5}$`)
    if m := re.FindStringSubmatch(podOrAgent); m != nil {
        return m[1]
    }
    // Otherwise, if it looks like agent-<timestamp>-something, take first two parts
    parts := strings.Split(podOrAgent, "-")
    if len(parts) >= 2 && strings.HasPrefix(podOrAgent, "agent-") {
        return parts[0] + "-" + parts[1]
    }
    // Fallback: return as-is
    return podOrAgent
}

func stopEditorForward(name string) bool {
    editorMu.Lock()
    pf, ok := editorPF[name]
    editorMu.Unlock()
    if !ok || pf.Cmd == nil { return false }
    // best-effort kill
    _ = pf.Cmd.Process.Kill()
    editorMu.Lock()
    delete(editorPF, name)
    if a, ok := agents[name]; ok {
        a.EditorPort = 0
        a.EditorVia = ""
        agents[name] = a
    }
    editorMu.Unlock()
    return true
}

func bearerOrHeaderToken(r *http.Request) string {
    // Prefer header X-Auth-Token, fallback to Authorization: Bearer <token>
    if t := r.Header.Get("X-Auth-Token"); t != "" { return t }
    if auth := r.Header.Get("Authorization"); auth != "" {
        const p = "Bearer "
        if len(auth) > len(p) && auth[:len(p)] == p { return auth[len(p):] }
    }
    return ""
}

func requireToken(next http.HandlerFunc, envVar string) http.HandlerFunc {
    required := os.Getenv(envVar)
    return func(w http.ResponseWriter, r *http.Request) {
        if required == "" { next(w, r); return }
        if token := bearerOrHeaderToken(r); token == required {
            next(w, r)
            return
        }
        http.Error(w, "unauthorized", http.StatusUnauthorized)
    }
}

func decodeJSON[T any](r *http.Request, v *T) error {
    b, err := io.ReadAll(r.Body)
    if err != nil { return err }
    if len(b) == 0 { return errors.New("empty body") }
    return json.Unmarshal(b, v)
}

func registerHandlers(mux *http.ServeMux) {
    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        h := Health{Status: "ok", Host: hostname()}
        writeJSON(w, h)
    })

    // Generate kubeconfig for an org by invoking talosctl inside this orchestrator container.
    // POST /kubeconfig/generate { org: string, endpoint: string }
    // Writes to /state/kube/<org>.config so both orchestrator and dashboard can read it.
    mux.HandleFunc("/kubeconfig/generate", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Org, Endpoint string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        req.Org = strings.TrimSpace(req.Org)
        req.Endpoint = strings.TrimSpace(req.Endpoint)
        if req.Org == "" || req.Endpoint == "" {
            http.Error(w, "missing org/endpoint", 400); return
        }
    // Ensure output dir exists
    base := stateBaseDir()
    _ = os.MkdirAll(base+"/kube", 0o755)
    outPath := base+"/kube/" + req.Org + ".config"
        // Run talosctl directly; include talosconfig if present for this org.
        args := []string{
            "kubeconfig",
            "--endpoints", req.Endpoint,
            "--force",
            "--nodes", req.Endpoint,
            "--merge=false",
            "--force-context-name", req.Org,
            outPath,
        }
        // If a talosconfig exists and has meaningful content, pass it explicitly
    if fi, err := os.Stat(base+"/talos/" + req.Org + ".talosconfig"); err == nil && fi.Size() > 0 {
        if b, err := os.ReadFile(base+"/talos/" + req.Org + ".talosconfig"); err == nil {
                txt := string(b)
                hasMeaning := false
                for _, line := range strings.Split(txt, "\n") {
                    t := strings.TrimSpace(line)
                    if t != "" && !strings.HasPrefix(t, "#") { hasMeaning = true; break }
                }
                if hasMeaning && (strings.Contains(strings.ToLower(txt), "context:") || strings.Contains(strings.ToLower(txt), "contexts:")) {
            args = append([]string{"--talosconfig", base+"/talos/" + req.Org + ".talosconfig"}, args...)
                }
            }
        }
        cmd := exec.Command("talosctl", args...)
        cmd.Env = os.Environ()
        out, err := cmd.CombinedOutput()
        if err != nil {
            code := 1
            if ee, ok := err.(*exec.ExitError); ok { code = ee.ExitCode() }
            w.WriteHeader(500)
            writeJSON(w, map[string]any{
                "ok": false,
                "error": err.Error(),
                "exitCode": code,
                "output": string(out),
            })
            return
        }
        // Best effort: verify file exists
        if _, err := os.Stat(outPath); err != nil {
            w.WriteHeader(500)
            writeJSON(w, map[string]any{
                "ok": false,
                "error": "kubeconfig not written",
                "output": string(out),
                "path": outPath,
            })
            return
        }
        writeJSON(w, map[string]any{"ok": true, "path": outPath})
    }, "ORCHESTRATOR_TOKEN"))

    // Bootstrap an org's Talos cluster and produce working defaults without manual edits.
    // POST /orgs/bootstrap { org: string, cpNodes: [string], workerNodes?: [string] }
    // Steps: gen config -> apply to cp1 (init) -> apply to remaining CPs (controlplane) -> apply to workers (join) -> bootstrap -> write talosconfig/kubeconfig
    mux.HandleFunc("/orgs/bootstrap", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{
            Org string `json:"org"`
            CPNodes []string `json:"cpNodes"`
            WorkerNodes []string `json:"workerNodes"`
        }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        req.Org = strings.TrimSpace(req.Org)
        if req.Org == "" || len(req.CPNodes) == 0 { http.Error(w, "missing org/cpNodes", 400); return }
        cp1 := strings.TrimSpace(req.CPNodes[0])
        // Prepare dirs
    base := stateBaseDir()
    _ = os.MkdirAll(base+"/talos", 0o755)
    _ = os.MkdirAll(base+"/kube", 0o755)
        // Temp work dir per request
        workDir := "/tmp/talos-" + req.Org + "-" + time.Now().Format("20060102150405")
        _ = os.MkdirAll(workDir, 0o755)
        run := func(name string, args ...string) (string, error) {
            cmd := exec.Command(name, args...)
            cmd.Env = os.Environ()
            out, err := cmd.CombinedOutput()
            if err != nil {
                if ee, ok := err.(*exec.ExitError); ok {
                    return string(out), fmt.Errorf("%s failed (code %d): %w\n%s", name, ee.ExitCode(), err, string(out))
                }
                return string(out), fmt.Errorf("%s failed: %w\n%s", name, err, string(out))
            }
            return string(out), nil
        }
        outputs := make([]string, 0, 8)
        appendOut := func(tag, out string) { outputs = append(outputs, fmt.Sprintf("[%s]\n%s", tag, out)) }
        // 1) gen config (produces controlplane.yaml, worker.yaml, and talosconfig)
        out, err := run("talosctl", "gen", "config", req.Org, "https://"+cp1+":6443", "--output-dir", workDir)
        appendOut("gen config", out)
        if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
        // Sanity: ensure expected files exist
        cpFile := workDir+"/controlplane.yaml"
        wkFile := workDir+"/worker.yaml"
        if _, e := os.Stat(cpFile); e != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": "missing controlplane.yaml: "+e.Error(), "log": strings.Join(outputs, "\n")}); return }
        if _, e := os.Stat(wkFile); e != nil { appendOut("warn", "worker.yaml not found; proceeding without worker configs") }
    // 2) apply initial control-plane (use mode=auto for initial bring-up)
    out, err = run("talosctl", "--nodes", cp1, "apply-config", "--insecure", "--file", cpFile, "--mode=auto")
        appendOut("apply init", out)
        if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
        // 3) apply controlplane to the rest of CP nodes
        if len(req.CPNodes) > 1 {
            for _, n := range req.CPNodes[1:] {
                n = strings.TrimSpace(n); if n == "" { continue }
                out, err = run("talosctl", "--nodes", n, "apply-config", "--insecure", "--file", cpFile)
                appendOut("apply controlplane "+n, out)
                if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
            }
        }
        // 4) apply join to workers
        for _, wn := range req.WorkerNodes {
            wn = strings.TrimSpace(wn); if wn == "" { continue }
            // use worker.yaml
            out, err = run("talosctl", "--nodes", wn, "apply-config", "--insecure", "--file", wkFile)
            appendOut("apply worker "+wn, out)
            if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
        }
        // 5) bootstrap
    talosPath := base+"/talos/" + req.Org + ".talosconfig"
        // The generated talosconfig is usually named 'talosconfig' in the output dir
        if b, rerr := os.ReadFile(workDir+"/talosconfig"); rerr == nil { _ = os.WriteFile(talosPath, b, 0o600) }
        argsBoot := []string{"--endpoints", cp1, "bootstrap"}
        if _, e := os.Stat(talosPath); e == nil { argsBoot = append([]string{"--talosconfig", talosPath}, argsBoot...) }
        out, err = run("talosctl", argsBoot...)
        appendOut("bootstrap", out)
        if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
        // 6) kubeconfig
    outPath := base+"/kube/" + req.Org + ".config"
        argsKC := []string{"kubeconfig", "--endpoints", cp1, "--force", "--nodes", cp1, "--merge=false", "--force-context-name", req.Org, outPath}
        if _, e := os.Stat(talosPath); e == nil { argsKC = append([]string{"--talosconfig", talosPath}, argsKC...) }
        out, err = run("talosctl", argsKC...)
        appendOut("kubeconfig", out)
        if err != nil { w.WriteHeader(500); writeJSON(w, map[string]any{"ok": false, "error": err.Error(), "log": strings.Join(outputs, "\n")}); return }
        writeJSON(w, map[string]any{"ok": true, "talos": talosPath, "kubeconfig": outPath, "log": strings.Join(outputs, "\n")})
    }, "ORCHESTRATOR_TOKEN"))

    // Deploy an agent into the org cluster.
    // CRD-only architecture: agents are managed by the Operator when tasks are scheduled.
    // This endpoint remains for compatibility and returns a no-op success.
    // POST /agents/deploy { org: string, image?: string }
    mux.HandleFunc("/agents/deploy", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        // For CRD-only mode, no imperative/script deployment is performed.
        // The Operator is responsible for managing agent Pods when tasks are submitted.
        // Return a no-op success so callers can proceed without error.
        writeJSON(w, map[string]any{
            "ok": true,
            "mode": cfg.ModeCRDOperator,
            "note": "agents are managed by the Operator; deploy is a no-op",
        })
    }, "ORCHESTRATOR_TOKEN"))

    // Lightweight k8s reachability endpoint.
    // GET /k8s/ping?org=<org>
    mux.HandleFunc("/k8s/ping", func(w http.ResponseWriter, r *http.Request) {
        org := strings.TrimSpace(r.URL.Query().Get("org"))
        if org == "" { http.Error(w, "missing org", 400); return }
        cs, _, err := k8sfactory.LoadForOrg(org)
        if err != nil { http.Error(w, err.Error(), 500); return }
        ver, err := k8sfactory.Ping(r.Context(), cs)
        if err != nil { http.Error(w, err.Error(), 502); return }
        writeJSON(w, map[string]any{"org": org, "version": ver})
    })

    // Ensure base namespace exists for agents/operator
    // POST /k8s/prepare { org, namespace? }
    mux.HandleFunc("/k8s/prepare", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Org, Namespace string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if strings.TrimSpace(req.Org) == "" { http.Error(w, "missing org", 400); return }
        ns := strings.TrimSpace(req.Namespace)
        if ns == "" { ns = "mvp-agents" }
        cs, _, err := k8sfactory.LoadForOrg(req.Org)
        if err != nil { http.Error(w, err.Error(), 500); return }
        // Create Namespace if not exists
        _, err = cs.CoreV1().Namespaces().Get(r.Context(), ns, metav1.GetOptions{})
        if err != nil {
            // Try create
            _, cerr := cs.CoreV1().Namespaces().Create(r.Context(), &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: ns}}, metav1.CreateOptions{})
            if cerr != nil {
                http.Error(w, cerr.Error(), 502); return
            }
        }
        writeJSON(w, map[string]any{"ok": true, "namespace": ns})
    }, "ORCHESTRATOR_TOKEN"))

    // Proxy endpoint to expose a local forwarded editor port over the orchestrator's HTTP port.
    // Usage: GET /editor/proxy/{port}/... -> http://127.0.0.1:{port}/...
    mux.HandleFunc("/editor/proxy/", func(w http.ResponseWriter, r *http.Request) {
        // path = /editor/proxy/{port}/rest...
        p := strings.TrimPrefix(r.URL.Path, "/editor/proxy/")
        if p == "" { http.Error(w, "missing port", 400); return }
        seg := strings.SplitN(p, "/", 2)
        portStr := seg[0]
        rest := "/"
        if len(seg) == 2 && seg[1] != "" { rest = "/" + seg[1] }
        // Validate port
        if _, err := fmt.Sscanf(portStr, "%d", new(int)); err != nil {
            http.Error(w, "bad port", 400); return
        }
        // Prepare reverse proxy to the locally-forwarded port
        target, _ := url.Parse("http://127.0.0.1:" + portStr)
        rp := httputil.NewSingleHostReverseProxy(target)
        // Relax frame headers and leave Location/Cookies as-is; dashboard will rewrite on its side
        rp.ModifyResponse = func(resp *http.Response) error {
            resp.Header.Del("X-Frame-Options")
            resp.Header.Del("Content-Security-Policy")
            return nil
        }
        orig := rp.Director
        // Optional auth header for fallback Python server
        csHeader := os.Getenv("CODE_SERVER_AUTH_HEADER"); if csHeader == "" { csHeader = "X-Agent-Auth" }
        csToken := os.Getenv("CODE_SERVER_TOKEN"); if csToken == "" { csToken = "password" }
        rp.Director = func(req *http.Request) {
            orig(req)
            req.URL.Scheme = "http"
            req.URL.Host = "127.0.0.1:" + portStr
            req.URL.Path = rest
            // Preserve query string
            req.Host = req.URL.Host
            req.Header.Set(csHeader, csToken)
        }
        rp.ErrorHandler = func(w http.ResponseWriter, req *http.Request, err error) {
            http.Error(w, "proxy error: "+err.Error(), 502)
        }
        rp.ServeHTTP(w, r)
    })

    mux.HandleFunc("/peers", func(w http.ResponseWriter, r *http.Request) {
        peers := []string{}
        writeJSON(w, map[string]any{"peers": peers})
    })

    mux.HandleFunc("/clusters", func(w http.ResponseWriter, r *http.Request) {
        clusters := []map[string]string{}
        writeJSON(w, map[string]any{"clusters": clusters})
    })

    mux.HandleFunc("/schedule", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct { Org string `json:"org"`; Task string `json:"task"`; AgentHint string `json:"agentHint,omitempty"` }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Org == "" || req.Task == "" { http.Error(w, "missing org/task", 400); return }
        id := time.Now().Format("20060102-150405.000")
        t := Task{ID: id, Org: req.Org, Text: req.Task, Status: "scheduled", AgentHint: req.AgentHint, CreatedAt: time.Now()}
    mode := cfg.GetSchedulerMode()
        // CRD-operator mode: create an AgentTask CR
    if mode == cfg.ModeCRDOperator {
            _, restCfg, err := k8sfactory.LoadForOrg(req.Org)
            if err == nil && restCfg != nil {
                env := map[string]any{
                    "ORG_NAME": req.Org,
                    "ORCHESTRATOR_URL": os.Getenv("PUBLIC_ORCHESTRATOR_URL"),
                    "ORCHESTRATOR_TOKEN": os.Getenv("ORCHESTRATOR_TOKEN"),
                    "CODE_SERVER_PASSWORD": getenvDefault("CODE_SERVER_PASSWORD", "password"),
                    "CODE_SERVER_AUTH_HEADER": getenvDefault("CODE_SERVER_AUTH_HEADER", "X-Agent-Auth"),
                    "CODE_SERVER_TOKEN": getenvDefault("CODE_SERVER_TOKEN", "password"),
                }
                spec := map[string]any{"orgId": req.Org, "task": req.Task, "env": env}
                name := "atask-" + strings.ReplaceAll(id, ".", "-")
                if obj, cerr := k8sdep.CreateAgentTask(r.Context(), restCfg, "mvp-agents", name, spec); cerr == nil {
                    // hint agent name if the controller will set it based on org
                    if obj != nil { t.AgentHint = name }
                    t.Status = "submitted"
                }
            }
        }
        tasksMu.Lock(); tasks[id] = t; tasksMu.Unlock()
        log.Printf("scheduled task id=%s org=%s text=%q", id, req.Org, req.Task)
        writeJSON(w, t)
    }, "ORCHESTRATOR_TOKEN"))

    mux.HandleFunc("/tasks", func(w http.ResponseWriter, r *http.Request) {
        tasksMu.RLock(); defer tasksMu.RUnlock()
        out := make([]Task, 0, len(tasks))
        for _, t := range tasks { out = append(out, t) }
        writeJSON(w, out)
    })
    // GET /tasks/status?id=<id>
    mux.HandleFunc("/tasks/status", func(w http.ResponseWriter, r *http.Request) {
        id := r.URL.Query().Get("id")
        if id == "" { http.Error(w, "missing id", 400); return }
        tasksMu.RLock(); t, ok := tasks[id]; tasksMu.RUnlock()
        if !ok { http.Error(w, "not found", 404); return }
    mode := cfg.GetSchedulerMode()
        // CRD mode: read AgentTask status
    if mode == cfg.ModeCRDOperator {
            if _, restCfg, err := k8sfactory.LoadForOrg(t.Org); err == nil {
                if obj, gerr := k8sdep.GetAgentTask(r.Context(), restCfg, "mvp-agents", "atask-"+strings.ReplaceAll(id, ".", "-")); gerr == nil && obj != nil {
                    writeJSON(w, map[string]any{"task": t, "crd": obj.Object}); return
                }
            }
        }
        writeJSON(w, map[string]any{"task": t})
    })
    mux.HandleFunc("/tasks/claim", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Org, AgentID string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Org == "" || req.AgentID == "" { http.Error(w, "missing org/agentId", 400); return }
        // prefer tasks that hint this agent, otherwise first scheduled task for org
        tasksMu.Lock(); defer tasksMu.Unlock()
        // pass 1: agent-hinted
        for id, t := range tasks {
            if t.Org == req.Org && t.Status == "scheduled" && t.AgentHint == req.AgentID {
                t.Status = "running"; t.AgentID = req.AgentID; tasks[id] = t
                writeJSON(w, t); return
            }
        }
        // pass 2: any scheduled
        for id, t := range tasks {
            if t.Org == req.Org && t.Status == "scheduled" {
                t.Status = "running"; t.AgentID = req.AgentID; tasks[id] = t
                writeJSON(w, t); return
            }
        }
        writeJSON(w, map[string]any{"task": nil})
    })
    mux.HandleFunc("/tasks/update", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ ID, Status, Log string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.ID == "" || req.Status == "" { http.Error(w, "missing id/status", 400); return }
        tasksMu.Lock(); defer tasksMu.Unlock()
        t, ok := tasks[req.ID]; if !ok { http.Error(w, "not found", 404); return }
        t.Status = req.Status; tasks[req.ID] = t
        writeJSON(w, t)
    })
    // POST /tasks/cancel { id }
    mux.HandleFunc("/tasks/cancel", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ ID string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.ID == "" { http.Error(w, "missing id", 400); return }
        tasksMu.Lock(); t, ok := tasks[req.ID]; tasksMu.Unlock()
        if !ok { http.Error(w, "not found", 404); return }
    mode := cfg.GetSchedulerMode()
    // CRD mode: set cancel=true on AgentTask CR
        if mode == cfg.ModeCRDOperator {
            if _, restCfg, err := k8sfactory.LoadForOrg(t.Org); err == nil {
                name := "atask-" + strings.ReplaceAll(req.ID, ".", "-")
                if _, uerr := k8sdep.SetAgentTaskCancel(r.Context(), restCfg, "mvp-agents", name, true); uerr != nil {
                    http.Error(w, uerr.Error(), 502); return
                }
            } else {
                // No kubeconfig available: degrade gracefully and still cancel locally
                log.Printf("cancel: skipping CRD update for org=%s: %v", t.Org, err)
            }
        }
        // Update local task status
        tasksMu.Lock(); t.Status = "cancelled"; tasks[req.ID] = t; tasksMu.Unlock()
        writeJSON(w, t)
    }, "ORCHESTRATOR_TOKEN"))
    mux.HandleFunc("/tasks/log", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ ID, Line string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.ID == "" { http.Error(w, "missing id", 400); return }
    if req.Line != "" { appendTaskLog(req.ID, req.Line); broadcastTask(req.ID, req.Line) }
        log.Printf("task[%s]: %s", req.ID, req.Line)
        w.WriteHeader(204)
    })
    mux.HandleFunc("/tasks/logs", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { http.Error(w, "method", 405); return }
        id := r.URL.Query().Get("id")
        if id == "" { http.Error(w, "missing id", 400); return }
        taskLogsMu.RLock(); lines := append([]string(nil), taskLogs[id]...); taskLogsMu.RUnlock()
        writeJSON(w, map[string]any{"id": id, "lines": lines})
    })
    // SSE: task logs
    mux.HandleFunc("/events/tasks", func(w http.ResponseWriter, r *http.Request) {
        id := r.URL.Query().Get("id")
        if id == "" { http.Error(w, "missing id", 400); return }
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        flusher, ok := w.(http.Flusher); if !ok { http.Error(w, "no flusher", 500); return }
        ch := make(chan string, 16)
        addTaskSub(id, ch); defer removeTaskSub(id, ch)
        // send backlog
        taskLogsMu.RLock(); for _, ln := range taskLogs[id] { io.WriteString(w, "data: "+ln+"\n\n") }; taskLogsMu.RUnlock(); flusher.Flush()
        notify := w.(http.CloseNotifier).CloseNotify()
        for {
            select {
            case ln := <-ch:
                io.WriteString(w, "data: "+ln+"\n\n"); flusher.Flush()
            case <-notify:
                return
            }
        }
    })
    mux.HandleFunc("/agents", func(w http.ResponseWriter, r *http.Request) {
        agentsMu.RLock(); defer agentsMu.RUnlock()
        out := make([]Agent, 0, len(agents))
        for _, a := range agents { out = append(out, a) }
        writeJSON(w, out)
    })
    // GET /agents/status?org=<org>&name=<name>
    mux.HandleFunc("/agents/status", func(w http.ResponseWriter, r *http.Request) {
        org := r.URL.Query().Get("org")
        name := r.URL.Query().Get("name")
        if org == "" || name == "" { http.Error(w, "missing org/name", 400); return }
        cs, _, err := k8sfactory.LoadForOrg(org)
        if err != nil { http.Error(w, err.Error(), 500); return }
        st, err := k8sdep.GetAgentStatus(r.Context(), cs, "mvp-agents", name)
        if err != nil { http.Error(w, err.Error(), 502); return }
        writeJSON(w, st)
    })
    mux.HandleFunc("/agents/register", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org string; Labels map[string]string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" || req.Org == "" { http.Error(w, "missing name/org", 400); return }
    a := Agent{Name: req.Name, Org: req.Org, Labels: req.Labels, Status: "idle", LastSeen: time.Now()}
        agentsMu.Lock(); agents[req.Name] = a; agentsMu.Unlock()
    // auto-open editor port-forward (best-effort)
    go func(name, org string) { _, _ = ensureEditorForward(name, org) }(req.Name, req.Org)
        writeJSON(w, a)
    })
    mux.HandleFunc("/agents/heartbeat", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org, Status string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        agentsMu.Lock(); a := agents[req.Name]; a.Name = req.Name; if req.Org != "" { a.Org = req.Org }; if req.Status != "" { a.Status = req.Status }; a.LastSeen = time.Now(); agents[req.Name] = a; agentsMu.Unlock()
        // best-effort ensure editor forward exists
        if a.EditorPort == 0 {
            go func(name, org string) { _, _ = ensureEditorForward(name, org) }(req.Name, req.Org)
        }
        writeJSON(w, map[string]string{"ok":"1"})
    })
    mux.HandleFunc("/agents/log", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Line string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
    if req.Line != "" { appendAgentLog(req.Name, req.Line); broadcastAgent(req.Name, req.Line) }
        log.Printf("agent[%s]: %s", req.Name, req.Line)
        w.WriteHeader(204)
    })
    mux.HandleFunc("/agents/logs", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodGet { http.Error(w, "method", 405); return }
        name := r.URL.Query().Get("name")
        if name == "" { http.Error(w, "missing name", 400); return }
        agentLogsMu.RLock(); lines := append([]string(nil), agentLogs[name]...); agentLogsMu.RUnlock()
        writeJSON(w, map[string]any{"name": name, "lines": lines})
    })
    
    // SSE: agent logs
    mux.HandleFunc("/events/agents", func(w http.ResponseWriter, r *http.Request) {
        name := r.URL.Query().Get("name")
        if name == "" { http.Error(w, "missing name", 400); return }
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        flusher, ok := w.(http.Flusher); if !ok { http.Error(w, "no flusher", 500); return }
        ch := make(chan string, 16)
        addAgentSub(name, ch); defer removeAgentSub(name, ch)
        // send backlog
        agentLogsMu.RLock(); for _, ln := range agentLogs[name] { io.WriteString(w, "data: "+ln+"\n\n") }; agentLogsMu.RUnlock(); flusher.Flush()
        notify := w.(http.CloseNotifier).CloseNotify()
        for {
            select {
            case ln := <-ch:
                io.WriteString(w, "data: "+ln+"\n\n"); flusher.Flush()
            case <-notify:
                return
            }
        }
    })
    // Editor control endpoints (token-protected)
    mux.HandleFunc("/agents/editor/open", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name, Org string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        port, err := ensureEditorForward(req.Name, req.Org)
        if err != nil { http.Error(w, err.Error(), 500); return }
        writeJSON(w, map[string]any{"name": req.Name, "port": port})
    }, "ORCHESTRATOR_TOKEN"))
    mux.HandleFunc("/agents/editor/close", requireToken(func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost { http.Error(w, "method", 405); return }
        var req struct{ Name string }
        if err := decodeJSON(r, &req); err != nil { http.Error(w, err.Error(), 400); return }
        if req.Name == "" { http.Error(w, "missing name", 400); return }
        ok := stopEditorForward(req.Name)
        writeJSON(w, map[string]any{"name": req.Name, "stopped": ok})
    }, "ORCHESTRATOR_TOKEN"))
}

func writeJSON(w http.ResponseWriter, v any) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(v)
}

func hostname() string {
    h, _ := os.Hostname()
    return h
}

func appendTaskLog(id, line string) {
    taskLogsMu.Lock(); defer taskLogsMu.Unlock()
    b := append(taskLogs[id], time.Now().Format(time.RFC3339)+" "+line)
    if len(b) > 200 { b = b[len(b)-200:] }
    taskLogs[id] = b
}

func appendAgentLog(name, line string) {
    agentLogsMu.Lock(); defer agentLogsMu.Unlock()
    b := append(agentLogs[name], time.Now().Format(time.RFC3339)+" "+line)
    if len(b) > 200 { b = b[len(b)-200:] }
    agentLogs[name] = b
}

func addTaskSub(id string, ch chan string) {
    taskSubsMu.Lock(); defer taskSubsMu.Unlock()
    m := taskSubs[id]; if m == nil { m = make(map[chan string]struct{}); taskSubs[id] = m }
    m[ch] = struct{}{}
}
func removeTaskSub(id string, ch chan string) {
    taskSubsMu.Lock(); defer taskSubsMu.Unlock()
    if m := taskSubs[id]; m != nil { delete(m, ch) }
}
func broadcastTask(id, ln string) {
    taskSubsMu.Lock(); m := taskSubs[id]; taskSubsMu.Unlock()
    for ch := range m { select { case ch <- ln: default: } }
}

func addAgentSub(name string, ch chan string) {
    agentSubsMu.Lock(); defer agentSubsMu.Unlock()
    m := agentSubs[name]; if m == nil { m = make(map[chan string]struct{}); agentSubs[name] = m }
    m[ch] = struct{}{}
}
func removeAgentSub(name string, ch chan string) {
    agentSubsMu.Lock(); defer agentSubsMu.Unlock()
    if m := agentSubs[name]; m != nil { delete(m, ch) }
}
func broadcastAgent(name, ln string) {
    agentSubsMu.Lock(); m := agentSubs[name]; agentSubsMu.Unlock()
    for ch := range m { select { case ch <- ln: default: } }
}
